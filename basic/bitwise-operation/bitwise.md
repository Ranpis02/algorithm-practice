# 1 位运算

| 运算操作 | 运算符 | 介绍                                                         |
| -------- | ------ | ------------------------------------------------------------ |
| `AND`    | `&`    | 两个位都为 `1` 时，结果才为 `1`，否则为 `0`                  |
| `OR`     | `|`    | 两个位有一个为 `1` 时，结果为 `1`，否则为 `0`                |
| `XOR`    | `^`    | 两个位不同时（一个为 `1`，另一个为 `0`）时，结果为 `1`，否则为 `0` |
| `NOT`    | `~`    | 取反操作，即原来为 `1`，取反后转换为 `0`，反之则反           |



| 运算操作      | 运算符 | 介绍                                                      |
| ------------- | ------ | --------------------------------------------------------- |
| `Left Shift`  | `<<`   | 将所有二进制位向左移 `k` 位，右边空出的位补 0             |
| `Right Shift` | `>>`   | 将所有二进制位向右移 `k` 位，右边空出的位取决于具体的类型 |



Left Shift

```
0000 1100  (12)
<< 1
----------------
  0001 1000  (24)
```

> `n << k` 等价于 `n * (2^k)`。例如 `n << 1` 就是 `n * 2`



Right Shift

```
0000 1100  (12)
>> 1
----------------
  0000 0110  (6)
```

>`n >> k` 等价于 `n / (2^k)`。例如 `n >> 1` 就是 `n / 2`



# 2 常见问题

## 2.1 Population Count

"Population Count" 是一个经典利用位运算解决的问题，即统计数字 `n` 的二进制数种 `1` 的个数。我们有两种解决思路：

1. BK 算法：即通过 `n & (n - 1)` 消去最右侧的 `1` 来实现快速统计

   ```cpp
   int countOnes(int n)
   {
     int cnt = 0;
     while (n > 0)
     {
       n = n & (n - 1);
       cnt++;
     }
   
     return cnt;
   } 
   ```

   > [!note]
   >
   > 这种方法是最快的，因为它直接就能定位到二进制数中的 `1` 的位置

2. 逐位检查法：主要是通过 `n & 1` 来检查最右侧的位是否为 `1`，并结合 `n >> 1` 操作，不断移位扫描

   ```cpp
   int countOnes(int n)
   {
     int cnt = 0;
     while (n > 0)
     {
       if (n & 1)
       {
         cnt++;
       }
       n >>= 1;
     }
   
     return cnt;
   }
   ```





